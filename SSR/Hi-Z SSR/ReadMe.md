# SSR技术分析-以U3d-HDRP为例

HDRP目前使用的是Hi-Z的方案。

# 步进逻辑简述

先大概简述一下这个步进的逻辑以及为什么能够加速。

首先我们需要用到一个叫Hi-Z结构的深度图。本质上其实就是一个经历过若干次池化操作的深度图集。至于使用的是最大池化还是最小池化取决于引擎对near的定义是0还是1。Unity使用的是1，也就意味着离相机更近的物体深度值更大。而我们判断一个射线是否和场景有交点则是判断射线是否比场景深度更远。（即在unity中我们的判别条件是射线深度比场景深度更小。）

借用一下图：

![Untitled](SSR%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90-%E4%BB%A5U3d-HDRP%E4%B8%BA%E4%BE%8B%202d5e732d23c849db9c4f27c70fc0465a/Untitled.png)

**由于整个循环发生在屏幕空间下，所以我们需要先声明一个问题是论文给出的结论是深度在屏幕空间下的变化是线性的。也就是说屏幕空间上的一个点沿着某个方向移动，深度的变化是线性且连续的。基于这个结论我们才能在屏幕空间下做深度步进。**

在第一次初始化进行步进的时候，我们需要根据起点（也就是我们场景中每一个需要被计算反射的点）和步进方向做一次偏移的初始化，以避免自相交（也就是如果我们不做任何初始偏移的话，用射线深度和场景深度是同一个值，而此时又处于同一个四叉树级别，就会让系统误判为已经发生了相交，循环就结束了。如何找到这个巧妙的、轻微的初始值后面具体代码实现再说）。如图：

![Untitled](SSR%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90-%E4%BB%A5U3d-HDRP%E4%B8%BA%E4%BE%8B%202d5e732d23c849db9c4f27c70fc0465a/Untitled%201.png)

然后我们就得到了两个东西，一个是这个起点沿着步进方向偏移一定量距离后，得到的一个射线。另外一个我们得到了射线所处于的cell的位置索引。我们用$Ray$来代表射线。用$Cell$来代表射线所处的像素索引。

伪代码如下：

```glsl
float3 currentRay = startPoint + dir * minimumDistance;
float2 cellIndex = getCell(currentRay);
```

然后我们用这个射线所在位置索引$Cell_{xy}$来采样当前四叉树深度下的深度值，如果是第一次步进那取决于我们的开始级别是多少，Unity的做法是让起始级别设置为0，也就是最精细的深度级别。然后我们用射线的深度$Ray_z$ 和 $Cell_z$做对比，也就是上面提到的判别相交的条件。如果$Ray_z > Cell_z$，那就说明我们的射线没有击中任何的东西（如果没有四叉树加速的话，此时我们只能够让射线继续往下一个像素去步进。但由于我们有四叉树，所以我们可以做一些跳过一些像素的操作来加速。）

我们看这个图的具体解释：

![Untitled](SSR%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90-%E4%BB%A5U3d-HDRP%E4%B8%BA%E4%BE%8B%202d5e732d23c849db9c4f27c70fc0465a/Untitled%202.png)

（射线步进的深度比这个像素下的深度要近，说明没有任何相交）

。此时我们可以**直接**把射线的位置沿着步进的方向移动到下一个像素点。我们使用的是$NextCell_{xy}$作为我们的步进距离，也就是说我们直接把射线位移的距离设置为 **“刚好到达下一个cell”** 的距离。

这里的逻辑是当前四叉树深度下（尽管第一次的四叉树深度级别是最精细的级别，但是原理是一样的），我们的射线已经步进到这个位置了，但是你当前的深度还是没有我的近，那我就可以跳过你直接到下一个像素点。而且我“飘了”，我要找周围像素中“最能打的”的像素和我对比，所以要提升一个四叉树深度来作比较（潜台词就是如果我比你们周围最近的那个都要近，那其他像素就没有比较的意义了，直接去下一个cell进行比较）

如图：

![Untitled](SSR%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90-%E4%BB%A5U3d-HDRP%E4%B8%BA%E4%BE%8B%202d5e732d23c849db9c4f27c70fc0465a/Untitled%203.png)

![Untitled](SSR%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90-%E4%BB%A5U3d-HDRP%E4%B8%BA%E4%BE%8B%202d5e732d23c849db9c4f27c70fc0465a/Untitled%204.png)

通过这样就可以加速我们的步进距离，可以看到每一次的位移的距离都比上一次的更远。这里是因为我们对深度图做了Hi-Z的操作，也就意味着虽然我们每次都是步进至少一个Cell的单位，但是在不同的四叉树深度下Cell对应的屏幕像素大小是不同的，Cell越少对应的distance就越大。从而使得我们可以快速跳过那些空白的区域。

假设我们经过了若干步骤以后，我们步进到的四叉树深度终于比射线的深度更近，此时我们可以认为它有可能发生了相交。如上图黄色部分所示。但是我们仍然不确定我们是否真的有相交，因为通常这个情况下我们已经处于一个比较高级别的四叉树之中，我们还需要找到确切相交的那个点。那么这时候我们就需要降低四叉树的深度，并让射线的位置不要再作移动，再进行对比：

![Untitled](SSR%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90-%E4%BB%A5U3d-HDRP%E4%B8%BA%E4%BE%8B%202d5e732d23c849db9c4f27c70fc0465a/Untitled%205.png)

此时可能会有两种情况，，第一种情况是我们回归到更低一级的四叉树深度时发现我们比当前像素的深度更近；第二种情况是我们发现射线的深度仍然比四叉树深度更远，那我们就又开始继续回归到更低一级的四叉树深度，直至回到最低级。（如果一直回归到最低的级别，就说明我们找到了交点了。）所以这里讨论的是第一种情况。

而要讨论第一种情况，这里要提及到前面说到的光线步进的时候有一个细节故意没有说，那就是我们在移动射线到下一个cell之前，我们还需要预计算一个深度差的距离$D_z$，以判别我们到底用上面提及的$NextCell_{xy}$作为我们的步进距离，还是使用这个深度差距离$D_z$。

如图：

![Untitled](SSR%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90-%E4%BB%A5U3d-HDRP%E4%B8%BA%E4%BE%8B%202d5e732d23c849db9c4f27c70fc0465a/Untitled%206.png)

我们看到当我们的射线深度和四叉树深度非常接近的时候，有可能我们只需要让射线“稍微”再偏移一定的距离，就可以让射线到达当前四叉树的深度，而达到“击中”的条件判别。而此时我们发现起点和终点都不足以让当前射线偏离到下一个cell，**此时我们认为击中的点很可能还保留在这个cell以内**。当发生了这种情况的时候，哪怕我们的当前射线并没有“击中”当前四叉树的深度，我们仍然不需要把四叉树的深度再往上提高一个级别，相反我们应该像上面第二种情况那样处理，把当前的四叉树深度再降低，再去逼近更精确的像素点。

所以我们在这里实际上有两种类型的步进，一个是朝着深度去逼近，另外一个是朝着Cell的方向去逼近。而优先级则是我们先逼近深度，再逼近Cell。而四叉树的等级只会根据我们最后是否发生了cell的偏移而判别，而非上面步骤中提及到的仅仅判别是否有“击中”作为条件。

之所以有深度逼近的这一条件，正是最开头提及到的射线在屏幕空间中的移动其深度值可以被看作是线性的，也就意味着我们在一个像素内移动极其细小的范围也会引起深度的线性变化。（而深度由于是由若干个像素组成的，和现实物理世界不一样，不能够无限的去细分。所以在单个像素内的深度值也会有很细微的变化，只是这些变化没有被表现出来）

所以至此我们就简述完成了整个步进的逻辑。简单说来规则就是：

1. 先步进射线，获得射线所在的cell的位置和深度
2. 根据射线所在的cell的位置去获取当前四叉树的深度
3. 用射线深度和四叉树深度进行对比，如果击中了，我们跳到到第四步。如果没有击中，我们跳到第五步。
4. 降低一个lod级别并保留当前射线的位置，回到第一步。
5. 用深度差作为距离，让射线去步进，得到一个新的位置，并判别新位置和原位置是否发生了以Cell为单位的偏移。如果发生了偏移，跳到第六步，否则跳到第七步
6. 提升一个lod级别，并且使用下一个cell的位置作为距离（而非使用深度差作为距离），让射线步进。
7. 保留深度差的步进结果（即让射线使用深度差的距离来步进，并保留这个位置），然后跳到第四步
8. 循环上面的步骤，直到我们处于最低级别的LOD0并且符合击中的条件。此时把射线的位置记录下来，就是我们的hitPoint

上述的过程略过了很多的细节，比如当射线是朝相机方向发射的时候的处理，击中时最大厚度的问题，以及如何让射线“恰好”偏移到下一个cell的边界的offset的取值问题等。这些在后面的代码解释中再去一步一步描述。